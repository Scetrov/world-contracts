import * as fs from "fs";
import * as path from "path";

interface ErrorDefinition {
    moduleName: string;
    errorCode: number;
    constantName: string;
    errorMessage: string;
}

/**
 * Extracts error definitions from Move source files
 */
function extractErrorsFromMoveFile(filePath: string): ErrorDefinition[] {
    let content: string;
    try {
        content = fs.readFileSync(filePath, "utf-8");
    } catch (error) {
        console.error(`Error reading file ${filePath}:`, error);
        return [];
    }
    const errors: ErrorDefinition[] = [];

    // Extract module name
    const moduleMatch = content.match(/module\s+world::(\w+)\s*;/);
    if (!moduleMatch) {
        return errors;
    }
    const moduleName = moduleMatch[1];

    const errorRegex =
        /#\[error\(code\s*=\s*(\d+)\)\]\s*const\s+([A-Z][A-Za-z0-9_]+)\s*:\s*vector<u8>\s*=\s*b"([^"]+)"/gs;

    let match;
    while ((match = errorRegex.exec(content)) !== null) {
        const errorCode = parseInt(match[1], 10);
        const constantName = match[2];
        const errorMessage = match[3];

        errors.push({
            moduleName,
            errorCode,
            constantName,
            errorMessage,
        });
    }

    return errors;
}

/**
 * Recursively finds all .move files in a directory
 */
function findMoveFiles(dir: string): string[] {
    const files: string[] = [];

    function walkDir(currentDir: string) {
        const entries = fs.readdirSync(currentDir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(currentDir, entry.name);

            if (entry.isDirectory()) {
                // Skip build directories and dependencies
                if (
                    entry.name !== "build" &&
                    entry.name !== "dependencies" &&
                    entry.name !== "node_modules"
                ) {
                    walkDir(fullPath);
                }
            } else if (entry.isFile() && entry.name.endsWith(".move")) {
                files.push(fullPath);
            }
        }
    }

    walkDir(dir);
    return files;
}

/**
 * Generates the error map TypeScript file
 */
function generateErrorMap(outputPath: string, contractsDir: string) {
    const moveFiles = findMoveFiles(contractsDir);
    const allErrors: ErrorDefinition[] = [];

    for (const file of moveFiles) {
        const errors = extractErrorsFromMoveFile(file);
        allErrors.push(...errors);
    }

    // Group by module name
    // Structure: module -> errorCode -> { constantName, errorMessage }
    const errorMap: Record<
        string,
        Record<number, { constantName: string; errorMessage: string }>
    > = {};

    for (const error of allErrors) {
        if (!errorMap[error.moduleName]) {
            errorMap[error.moduleName] = {};
        }
        errorMap[error.moduleName][error.errorCode] = {
            constantName: error.constantName,
            errorMessage: error.errorMessage,
        };
    }

    // Generate TypeScript file
    const typeDef =
        "Record<string, Record<number, { constantName: string; errorMessage: string }>>";
    const tsContent = `// Auto-generated file - do not edit manually
// This file is generated by error-extractor.ts
// Run: npm run extract:errors

export const ERROR_MAP: ${typeDef} = ${JSON.stringify(errorMap, null, 2)};

/**
 * Gets the error constant name for a given module and error code
 */
export function getErrorConstantName(moduleName: string, errorCode: number): string | undefined {
    return ERROR_MAP[moduleName]?.[errorCode]?.constantName;
}

/**
 * Gets the error message for a given module and error code
 */
export function getErrorMessage(moduleName: string, errorCode: number): string | undefined {
    return ERROR_MAP[moduleName]?.[errorCode]?.errorMessage;
}

/**
 * Gets both the error constant name and message for a given module and error code
 */
export function getErrorInfo(
    moduleName: string,
    errorCode: number
): { constantName: string; errorMessage: string } | undefined {
    return ERROR_MAP[moduleName]?.[errorCode];
}
`;

    fs.writeFileSync(outputPath, tsContent, "utf-8");
    console.log(
        `Generated error map with ${allErrors.length} error definitions from ${moveFiles.length} Move files`
    );
    console.log(`Modules found: ${Object.keys(errorMap).join(", ")}`);
}

// Main execution
// Get the directory of this script file
// Use process.cwd() as base and resolve relative to project root
const projectRoot = process.cwd();
const contractsDir = path.join(projectRoot, "contracts/world/sources");
const outputPath = path.join(projectRoot, "tools/error-decoder/error-map.ts");

if (!fs.existsSync(contractsDir)) {
    console.error(`Error: Contracts directory not found at ${contractsDir}`);
    process.exit(1);
}

generateErrorMap(outputPath, contractsDir);
